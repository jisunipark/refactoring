# Chapter 1 - 리팩터링: 첫 번째 예시

[velog](https://velog.io/@jisunipark/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-2%ED%8C%90-Chapter-1-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%98%88%EC%8B%9C)

리팩터링 2판 읽기 스터디를 시작했다. 일주일에 한 챕터씩 읽고 함께 책 내용에 대해 이야기 나눠보는 스터디다. 안 그래도 스프린트 과정 끝나고서 개발 서적 많이 읽으려고 하던 와중이었는데 좋다!

첫 챕터에는 예시 코드를 차근차근 정리해가며 리팩터링이 어떤 식으로 이루어지는지 그 예시가 나온다. 확실히 예시를 코드를 따라가며 실제로 컴퓨터로 따라 작성해보니 리팩터링을 어떻게 해야 하는지 대략적으로나마 감이 잡힌다. [깃헙 레포도 하나 팠다.](https://github.com/jisunipark/refactoring)

![](https://velog.velcdn.com/images/jisunipark/post/54923dc6-6af7-4e69-976d-ad27e752ddb2/image.png)

**책 읽어 나가면서 내가 작성했던 예전 코드들도 이 책에서 소개하는 방법대로 하나 하나 리팩터링 해봐야겠다!
**

## Quotes & Notes

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 **기능을 추가하기 쉬운 형태**로 리팩터링하고 나서 원하는 기능을 추가한다.

> 리팩터링하기 전에 제대로 된 **테스트부터** 마련한다. 테스트는 반드시 자가진단하도록 만든다.

> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. **사람이 이해하도록** 작성하는 프로그래머가 진정한 실력자다.

> 나는 함수의 반환 값에는 항상 **result**라는 이름을 쓴다.

_→ 이 방법 괜찮은 것 같다. 나도 따라해봐야지._

> 따라서 리팩터링응로 인한 **성능 문제**에 대한 내 조언은 **‘특별한 경우가 아니라면 일단 무시하라’**는 것이다. 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.

> 간결함이 지혜의 정수일지 몰라도, 프로그래밍에서만큼은 **명료함**이 진화할 수 있는 소프트웨어의 정수다.

_→ 무엇이든 ‘심미성’을 중요하게 여기는 나로서 코드에서도 ‘심미성’이 중요하지 않나 생각해왔었다. 나름 ‘아름다운 코드’가 무엇인지 정의 내려보았을 때, ‘아주 적절한 네이밍으로 이루어져 있는 미니멀한 코드’라고 생각했다. 나는 간결한 코드가 좋은 코드라고 생각했는데 이번 챕터를 읽다보니 ‘간결함’과 ‘명료함’은 또 다른 이야기인 것 같다. 간결하면서도 명료하다면 가장 좋겠지만, 프로그래밍에 있어서는 간결함보다는 명료함이 우선이 되어야 한다._

> 리팩터링은 대부분 **코드가 하는 일을 파악**하는 데서 시작한다.

> 좋은 코드를 가늠하는 확실한 방법은 ‘**얼마나 수정하기 쉬운가**’다.

> 리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 **작은 단계들이 모여서 상당히 큰 변화를** 이룰 수 있다는 사실을 깨닫는 것이다.
